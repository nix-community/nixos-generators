#!/usr/bin/env bash
set -euo pipefail

## Configuration

readonly libexec_dir="${0%/*}"

configuration=${NIXOS_CONFIG:-$libexec_dir/configuration.nix}
flake_uri=
flake_attr=
format=
format_path=
target_system=
cores=
run=
list_formats=false
show_format_search_path=false
nix_args=(
  "$libexec_dir/nixos-generate.nix"
)
has_outlink=false
nix_build_args=()

# `printf' rather than `<<<' to avoid introducing a spurious trailing newline
mapfile -t -d : format_dirs < <(printf -- '%s' "${NIXOS_GENERATORS_FORMAT_SEARCH_PATH:-}")
format_dirs+=("$libexec_dir/formats")

## Functions

showUsage() {
  cat <<USAGE
Usage: $0 [options]

Options:

* --help: shows this help
* -c, --configuration PATH:
    select the nixos configuration to build. Default: $configuration
* --flake URI:
    selects the nixos configuration to build, using flake uri like "~/dotfiles#my-config"
* -f, --format NAME: select one of the pre-determined formats
* --format-path PATH: pass a custom format
* --format-search-path DIR:
    prepend a directory to the list of directories ${0##*/} searches for format definitions
* --list: list the available formats
* --show-format-search-path:
    list the directories ${0##*/} searches for format files
* --run: runs the configuration in a VM
         only works for the "vm" and "vm-nogui" formats
* --show-trace: show more detailed nix evaluation location information
* --system: specify the target system (eg: x86_64-linux)
* -o, --out-link: specify the outlink location for nix-build
* --cores : to control the maximum amount of parallelism. (see nix-build documentation)
* --option : Passed to nix-build (see nix-build documentation).
* -I KEY=VALUE: Add a key to the Nix expression search path.
USAGE
}

listFormats() {
  local -A formats
  local format_dir format_file format

  for format_dir in "${format_dirs[@]}"; do
    if [[ -n $format_dir ]]; then
      for format_file in "$format_dir"/*.nix; do
          if [[ -f "$format_file" ]]; then
            format=$(basename "$format_file" ".nix")
            formats["$format"]=1
          fi
      done
    fi
  done

  for format in "${!formats[@]}"; do
    printf -- '%s\n' "$format"
  done | sort
}

showFormatSearchPath() {
  local format_dir

  for format_dir in "${format_dirs[@]}"; do
    if [[ -n $format_dir ]]; then
      printf -- '%s\n' "$format_dir"
    fi
  done
}

validateFormat() {
  case "${1:-}" in
    */* | '')
      abort "not a valid format name: ${1:-<empty>}"
      return 1
      ;;
  esac
}

findFormat() {
  local format="${1?}"
  shift

  validateFormat "$format" || return

  local -n ref_var="${1:-format_file}"
  shift

  local format_dir maybe_format_file

  for format_dir in "${format_dirs[@]}"; do
    if [[ -n $format_dir ]]; then
      maybe_format_file="${format_dir}/${format}.nix"

      if [[ -f "$maybe_format_file" ]]; then
        ref_var="$maybe_format_file"
        return
      fi
    fi
  done

  abort "unable to locate file for format: $format"
}

abort() {
  echo "aborted: $*" >&2
  exit 1
}

## Main ##

while [[ $# -gt 0 ]]; do
  case "$1" in
    -c | --configuration)
      configuration=$2
      shift
      ;;
    --flake)
      # Note: The reason I'm using awk over cut is because cutting with an
      # out-of-bounds field will return the last in-bound field instead of empty
      # string.
      flake="$(echo "$2" | awk -F'#' '{ print $1; }')"

      flake_uri="$(nix flake metadata --json -- "$flake" | jq -r .url)"
      flake_attr="$(echo "$2" | awk -F'#' '{ print $2; }')"
      shift
      ;;
    --cores)
      cores=$2
      shift
      ;;
    --option)
      nix_build_args+=("$1" "$2" "$3")
      shift 2
      ;;
    -f | --format)
      format="$2"
      shift
      ;;
    --format-path)
      format_path=$2
      shift
      ;;
    --format-search-path)
      format_dirs=("$2" "${format_dirs[@]}")
      shift
      ;;
    --help)
      showUsage
      exit
      ;;
    --list)
      list_formats=true
      show_format_search_path=false
      ;;
    --show-format-search-path)
      list_formats=false
      show_format_search_path=true
      ;;
    --run)
      run=1
      # default to the VM format
      format="${format:-vm}"
      ;;
    --show-trace)
      nix_args+=(--show-trace)
      ;;
    --system)
      target_system=$2
      shift
      ;;
    -I)
      nix_args+=(-I "$2")
      shift
      ;;
    -o | --out-link)
      nix_build_args+=(--out-link "$2")
      has_outlink=true
      shift
      ;;
    *)
      abort "unknown option $1"
      ;;
  esac
  shift
done

if $list_formats; then
  listFormats
  exit
elif $show_format_search_path; then
  showFormatSearchPath
  exit
fi

if ! $has_outlink; then
  nix_build_args+=(--no-out-link)
fi

if [[ -z $format_path ]]; then
  if [[ -n $format ]] ;then
    findFormat "$format" format_path
  else
    abort "missing format. use --help for more details"
  fi
fi

if [[ ! -f $format_path ]]; then
  abort "format file not found: $format_path"
fi

nix_args+=(--argstr formatConfig "$(realpath "$format_path")")

if [[ -z "$flake_uri" ]]; then
  nix_args+=(
    -I "nixos-config=$configuration"
  )
else
  nix_args+=(
    --argstr flakeUri "$flake_uri"
    --argstr flakeAttr "${flake_attr:-"$(hostname)"}"
  )
fi

if [[ -n $target_system ]]; then
  nix_args+=(--argstr system "$target_system")
fi

if [[ -n $cores ]]; then
  nix_args+=(--cores "$cores")
fi

formatAttr=$(nix-instantiate "${nix_args[@]}" --eval --json -A config.formatAttr | jq -r .)
filename=$(nix-instantiate "${nix_args[@]}" --eval --json -A config.filename | jq -r .)

out=$(nix-build "${nix_args[@]}" "${nix_build_args[@]}" -A "config.system.build.$formatAttr")

if [[ -z $run ]]; then
  # show the first file, ignoring nix-support
  find "$out" -wholename "$filename" -xtype f -print -quit
else
  runner=$(find "$out"/bin -type l -print -quit)
  exec "$runner"
fi
